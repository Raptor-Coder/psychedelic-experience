<html>
<head>
<title>Psychedelic Experience</title>
</head>
<body>
<canvas id="canvas"></canvas>
<button id="fullscreenToggle">Toggle Fullscreen</button>
<button id="audioToggle">Start Audio</button>
<div id="instructions">
  <h2>Instructions:</h2>
  <ul>
    <li>Move your mouse or finger to interact with the visualization</li>
    <li>Click or tap anywhere to change the visual mode</li>
    <li>Use the buttons at the bottom to toggle fullscreen and audio</li>
    <li>Enjoy the psychedelic experience!</li>
  </ul>
</div>
<script>
const canvas = document.getElementById('canvas');
const ctx = canvas.getContext('2d');
const fullscreenToggle = document.getElementById('fullscreenToggle');
const audioToggle = document.getElementById('audioToggle');
const instructions = document.getElementById('instructions');

canvas.width = window.innerWidth;
canvas.height = window.innerHeight;

let centerX = canvas.width / 2;
let centerY = canvas.height / 2;

let hue = 0;
let frame = 0;
let mouseX = 0;
let mouseY = 0;
let mouseSpeed = 0;
let mouseDistance = 0;

let visualMode = 0;
const totalModes = 13; // Increased number of modes

// Audio context and nodes
let audioContext;
let osc1, osc2, osc3, lfo, mainGain, reverbNode;
let isAudioInitialized = false;

function createReverb(duration = 2, decay = 2, reverse = false) {
  const sampleRate = audioContext.sampleRate;
  const length = sampleRate * duration;
  const impulse = audioContext.createBuffer(2, length, sampleRate);
  const impulseL = impulse.getChannelData(0);
  const impulseR = impulse.getChannelData(1);

  for (let i = 0; i < length; i++) {
    const n = reverse ? length - i : i;
    impulseL[i] = (Math.random() * 2 - 1) * Math.pow(1 - n / length, decay);
    impulseR[i] = (Math.random() * 2 - 1) * Math.pow(1 - n / length, decay);
  }

  const convolver = audioContext.createConvolver();
  convolver.buffer = impulse;
  return convolver;
}

function initAudio() {
  audioContext = new (window.AudioContext || window.webkitAudioContext)();
  
  osc1 = audioContext.createOscillator();
  osc2 = audioContext.createOscillator();
  osc3 = audioContext.createOscillator();
  lfo = audioContext.createOscillator();
  mainGain = audioContext.createGain();
  reverbNode = createReverb(3, 3);

  osc1.type = 'sine';
  osc2.type = 'triangle';
  osc3.type = 'sine';
  lfo.type = 'sine';

  osc1.frequency.setValueAtTime(220, audioContext.currentTime);
  osc2.frequency.setValueAtTime(329.63, audioContext.currentTime);
  osc3.frequency.setValueAtTime(440, audioContext.currentTime);
  lfo.frequency.setValueAtTime(0.1, audioContext.currentTime);

  mainGain.gain.setValueAtTime(0.1, audioContext.currentTime);

  lfo.connect(mainGain.gain);
  osc1.connect(mainGain);
  osc2.connect(mainGain);
  osc3.connect(mainGain);
  mainGain.connect(reverbNode);
  reverbNode.connect(audioContext.destination);

  osc1.start();
  osc2.start();
  osc3.start();
  lfo.start();

  isAudioInitialized = true;
}

function updateAudio() {
  if (!isAudioInitialized) return;

  const normalizedSpeed = mouseSpeed / 50;
  const normalizedDistance = mouseDistance / (Math.sqrt(canvas.width * canvas.width + canvas.height * canvas.height) / 2);

  osc1.frequency.setValueAtTime(220 + normalizedSpeed * 110, audioContext.currentTime);
  osc2.frequency.setValueAtTime(329.63 + normalizedDistance * 165, audioContext.currentTime);
  osc3.frequency.setValueAtTime(440 + (normalizedSpeed + normalizedDistance) * 110, audioContext.currentTime);
  
  lfo.frequency.setValueAtTime(0.1 + normalizedSpeed * 0.4, audioContext.currentTime);
  
  mainGain.gain.setValueAtTime(0.1 + normalizedDistance * 0.1, audioContext.currentTime);
}

function drawKaleidoscope(time) {
  const segments = 8 + Math.floor(mouseSpeed / 5);
  const size = Math.min(canvas.width, canvas.height) * 0.4;
  
  ctx.save();
  ctx.translate(centerX, centerY);
  
  for (let i = 0; i < segments; i++) {
    ctx.save();
    ctx.rotate((Math.PI * 2 / segments) * i);
    
    ctx.beginPath();
    for (let j = 0; j < 100; j++) {
      const t = j / 100;
      const radius = size * t * (1 + mouseDistance / 1000);
      const angle = Math.PI * 2 * t + time / 1000;
      const x = radius * Math.cos(angle);
      const y = radius * Math.sin(angle);
      
      if (j === 0) {
        ctx.moveTo(x, y);
      } else {
        ctx.lineTo(x, y);
      }
    }
    
    ctx.strokeStyle = `hsla(${(hue + i * 360 / segments) % 360}, 100%, 50%, 0.5)`;
    ctx.lineWidth = 2 + mouseSpeed / 20;
    ctx.stroke();
    
    ctx.restore();
  }
  
  ctx.restore();
}
